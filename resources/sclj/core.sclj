;; (ns sclj.core)

(def defmacro
  (macro [mname argv body]
   (quote
    (def (unquote mname)
      (macro (unquote argv)
        (unquote body))))))

(defmacro defn
  [fname argv body]
  (quote
   (def (unquote fname)
     (fn (unquote argv)
       (unquote body)))))

(defn macroexpand-1
  [form]
  (let [m (eval (first form))
        args (rest form)]
    (apply m args)))

(defn not [x]
  (if x false true))

(defn empty? [xs]
  (not (seq xs)))

(defn reduce
  [f acc xs]
  (if (seq xs)
    (reduce f (f acc (first xs)) (rest xs))
    acc))

(defn map
  [f xs]
  (if (seq xs)
    (cons (f (first xs))
          (map f (rest xs)))
    nil))

(defn concat
  [xs ys]
  (if (empty? xs)
    ys
    (if (empty? ys)
      xs
      (cons (first xs)
            (concat (rest xs) ys)))))

