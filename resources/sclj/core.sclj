;; (ns sclj.core)

(def defmacro
  (macro [mname argv body]
   (quote
    (def (unquote mname)
      (macro (unquote argv)
        (unquote body))))))

(defmacro defn
  [fname argv body]
  (quote
   (def (unquote fname)
     (fn (unquote argv)
       (unquote body)))))

(defn macroexpand-1
  [form]
  (let [m (eval (first form))
        args (rest form)]
    (apply m args)))

(defn not [x]
  (if x false true))

(defn empty? [xs]
  (not (seq xs)))

(defmacro lazy-seq [exp]
  (quote
   (lazy-seq*
    (fn []
      (unquote exp)))))

(defmacro if-let
  [bindings then else]
  (let [sym (first bindings)
        tst (first (rest bindings))
        tmp (gensym)]
    (quote
     (let [(unquote tmp) (unquote tst)]
       (if (unquote tmp)
         (unquote then)
         (unquote else))))))

(defn reduce
  [f acc xs]
  (if-let [xs (seq xs)]
    (reduce f (f acc (first xs)) (rest xs))
    acc))

(defn dorun [xs]
  (if-let [xs (seq xs)]
    (dorun (next xs))
    nil))

(defn doall [xs]
  (do
    (dorun xs)
    xs))

(defn map
  [f xs]
  (lazy-seq
   (if-let [xs (seq xs)]
     (cons (f (first xs))
           (map f (rest xs)))
     nil)))

(defn filter
  [f xs]
  (lazy-seq
   (if-let [xs (seq xs)]
     (let [x (first xs)]
       (if (f x)
         (cons x (filter f (rest xs)))
         (filter f (rest xs))))
     nil)))

(defn concat
  [xs ys]
  (lazy-seq
   (if-let [xs (seq xs)]
     (cons (first xs)
           (concat (rest xs) ys))
     ys)))

#_(let [l1 (lazy-seq (list 10 11 12))
      l2 (cons 9 l1)
      l3 (concat l2 (list 13 14))
      l4 (map (fn [x] (+ x 1)) l3)]
  (println l4))
