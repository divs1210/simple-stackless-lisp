(ns sclj.core)

(def defmacro
  (macro [mname argv body]
   (quote
    (def (unquote mname)
      (macro (unquote argv)
        (unquote body))))))

(defmacro defn
  [fname argv body]
  (quote
   (def (unquote fname)
     (fn (unquote argv)
       (unquote body)))))

(defn macroexpand-1
  [form]
  (let [m (eval (first form))
        args (rest form)]
    (apply m args)))

(defn not [x]
  (if x false true))

(defn empty? [xs]
  (not (seq xs)))

(defmacro if-let
  [bindings then else]
  (let [sym (first bindings)
        tst (first (rest bindings))
        tmp (gensym)]
    (quote
     (let [(unquote tmp) (unquote tst)]
       (if (unquote tmp)
         (unquote then)
         (unquote else))))))

(defn reduce
  [f acc xs]
  (if-let [xs (seq xs)]
    (reduce f (f acc (first xs)) (rest xs))
    acc))

(defn map
  [f xs]
  (if-let [xs (seq xs)]
    (cons (f (first xs))
          (map f (rest xs)))
    nil))

(defn filter
  [f xs]
  (if-let [xs (seq xs)]
    (let [x (first xs)]
      (if (f x)
        (cons x (filter f (rest xs)))
        (filter f (rest xs))))
    nil))

(defn concat
  [xs ys]
  (if-let [xs (seq xs)]
    (cons (first xs)
          (concat (rest xs) ys))
    ys))

#_(let [l1 (list 10 11 12)
      l2 (cons 9 l1)
      l3 (concat l2 (list 13 14))
      l4 (map (fn [x] (+ x 1)) l3)]
  (println l4))
